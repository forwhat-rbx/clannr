import { robloxClient, robloxGroup } from '../main';
import { config } from '../config';
import { logAction } from '../handlers/handleLogging';
import { Logger } from '../utils/logger';
import { directGetGroupAuditLogs } from '../utils/directAuth';
import { PartialUser } from 'bloxy/dist/structures';

// Track the last recorded audit log timestamp
let lastRecordedDate: number;

// Define TypeScript interface for user info response
interface RobloxUserResponse {
    id: number;
    name: string;
    displayName: string;
    description: string;
    created: string;
    isBanned: boolean;
    hasVerifiedBadge: boolean;
}

const recordAuditLogs = async () => {
    try {
        Logger.info('Checking audit logs...', 'Audit');

        // Use direct method to fetch audit logs instead of Bloxy
        let auditLogData;
        try {
            // Fetch audit logs using our direct implementation
            const response = await directGetGroupAuditLogs(
                process.env.ROBLOX_COOKIE,
                config.groupId,
                {
                    actionType: 'ChangeRank',
                    limit: 10,
                    sortOrder: 'Desc'
                }
            );

            auditLogData = response.data || [];
            Logger.info(`Found ${auditLogData.length} audit log entries`, 'Audit');
        } catch (directErr) {
            Logger.error('Failed to fetch audit logs directly:', 'Audit', directErr);
            auditLogData = [];
        }

        // If we have audit logs and they contain at least one entry
        if (auditLogData.length > 0) {
            // Get the timestamp of the most recent log
            const mostRecentDate = new Date(auditLogData[0].created).getTime();

            // If we've seen logs before, process any new ones
            if (lastRecordedDate) {
                // Get group roles for reference
                const groupRoles = await robloxGroup.getRoles();

                // Process each log entry
                for (const log of auditLogData) {
                    // Skip logs generated by the bot itself
                    if (log.actor?.user?.userId === global.botUserId) {
                        continue;
                    }

                    // Check if this log is newer than our last recorded timestamp
                    const logCreationDate = new Date(log.created);
                    if (Math.round(logCreationDate.getTime() / 1000) > Math.round(lastRecordedDate / 1000)) {
                        // Find role information
                        const oldRole = groupRoles.find((role) => role.id === log.description['OldRoleSetId']);
                        const newRole = groupRoles.find((role) => role.id === log.description['NewRoleSetId']);

                        if (oldRole && newRole) {
                            try {
                                // Get target user information
                                const targetId = log.description['TargetId'];
                                const response = await fetch(`https://users.roblox.com/v1/users/${targetId}`, {
                                    method: 'GET',
                                    headers: {
                                        'Cookie': `.ROBLOSECURITY=${process.env.ROBLOX_COOKIE}`,
                                        'Content-Type': 'application/json'
                                    }
                                });

                                // Parse the response with type information
                                const userInfo = await response.json() as RobloxUserResponse;

                                // Create a partial user object that satisfies the PartialUser requirements
                                const targetUser: any = {
                                    id: Number(targetId),
                                    name: userInfo.name || `User ${targetId}`,
                                    displayName: userInfo.displayName || userInfo.name || `User ${targetId}`,
                                    client: robloxClient, // Use the actual client
                                    getStatus: async () => "",
                                    getAvatar: async () => null,
                                    getCurrentlyWearing: async () => ({ assetIds: [] }),
                                    isBanned: async () => false,
                                    isOnline: async () => false,
                                };

                                // Then cast it to PartialUser when using it
                                logAction(
                                    'Manual Set Rank',
                                    log.actor.user,
                                    null,
                                    targetUser as PartialUser,
                                    `${oldRole.name} (${oldRole.rank}) â†’ ${newRole.name} (${newRole.rank})`
                                );
                            } catch (userError) {
                                Logger.error(`Failed to process user in audit log: ${userError.message}`, 'Audit');
                            }
                        }
                    }
                }
            }

            // Update our last recorded date for next time
            lastRecordedDate = mostRecentDate;
            Logger.info(`Updated last recorded audit log timestamp to ${new Date(lastRecordedDate).toISOString()}`, 'Audit');
        }
    } catch (err) {
        Logger.error('Error checking audit logs', 'Audit', err);
    }

    // Continue checking every 60 seconds even if there was an error
    setTimeout(recordAuditLogs, 60000);
};

export { recordAuditLogs };