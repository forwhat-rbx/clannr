import { config } from '../config';
import { logAction } from '../handlers/handleLogging';
import { Logger } from '../utils/logger';
import { directGetGroupAuditLogs, directGetGroupRoles } from '../utils/directAuth';
import { PartialUser } from 'bloxy/dist/structures';

// Track the last recorded audit log timestamp
let lastRecordedDate: number;
// Add a flag to track consecutive errors
let consecutiveErrors = 0;
// Add a variable to track check frequency (starts at 60 seconds)
let checkInterval = 60000;

// Define TypeScript interface for user info response
interface RobloxUserResponse {
    id: number;
    name: string;
    displayName: string;
    description?: string;
    created?: string;
    isBanned?: boolean;
    hasVerifiedBadge?: boolean;
}

const recordAuditLogs = async () => {
    try {
        Logger.info('Checking audit logs...', 'Audit');

        // Use direct method to fetch audit logs instead of Bloxy
        let auditLogData;
        try {
            // Fetch audit logs using our direct implementation
            const response = await directGetGroupAuditLogs(
                process.env.ROBLOX_COOKIE,
                config.groupId,
                {
                    actionType: 'ChangeRank',
                    limit: 10,
                    sortOrder: 'Desc'
                }
            );

            auditLogData = response.data || [];
            Logger.info(`Found ${auditLogData.length} audit log entries`, 'Audit');

            // Reset consecutive errors since this part succeeded
            consecutiveErrors = 0;
        } catch (directErr) {
            Logger.error('Failed to fetch audit logs directly:', 'Audit', directErr);
            auditLogData = [];
            consecutiveErrors++;
        }

        // If we have audit logs and they contain at least one entry
        if (auditLogData && auditLogData.length > 0) {
            // Get the timestamp of the most recent log
            const mostRecentDate = new Date(auditLogData[0].created).getTime();

            // If we've seen logs before and there are new ones to process
            if (lastRecordedDate && mostRecentDate > lastRecordedDate) {
                // Get group roles directly to avoid Bloxy issues
                let groupRoles;
                try {
                    groupRoles = await directGetGroupRoles(process.env.ROBLOX_COOKIE, config.groupId);
                } catch (rolesError) {
                    Logger.error('Failed to fetch group roles:', 'Audit', rolesError);
                    // Return early since we can't process without roles
                    return;
                }

                // Process each log entry
                for (const log of auditLogData) {
                    // Skip logs generated by the bot itself
                    if (log.actor?.user?.userId === global.botUserId) {
                        continue;
                    }

                    // Check if this log is newer than our last recorded timestamp
                    const logCreationDate = new Date(log.created);

                    if (Math.round(logCreationDate.getTime() / 1000) > Math.round(lastRecordedDate / 1000)) {
                        // Find role information
                        const oldRole = groupRoles.find((role) => role.id === log.description['OldRoleSetId']);
                        const newRole = groupRoles.find((role) => role.id === log.description['NewRoleSetId']);

                        if (oldRole && newRole) {
                            try {
                                // Get target user information
                                const targetId = log.description['TargetId'];
                                const response = await fetch(`https://users.roblox.com/v1/users/${targetId}`, {
                                    method: 'GET',
                                    headers: {
                                        'Cookie': `.ROBLOSECURITY=${process.env.ROBLOX_COOKIE}`,
                                        'Content-Type': 'application/json'
                                    }
                                });

                                if (!response.ok) {
                                    throw new Error(`Failed to fetch user with status ${response.status}`);
                                }

                                // Parse the response with proper type assertion
                                const userInfo = await response.json() as RobloxUserResponse;

                                // Create a partial user object that satisfies the PartialUser requirements
                                const targetUser: any = {
                                    id: Number(targetId),
                                    name: userInfo.name || `User ${targetId}`,
                                    displayName: userInfo.displayName || userInfo.name || `User ${targetId}`,
                                };

                                // Create an actor user object (avoiding Bloxy)
                                const actorUser: any = {
                                    id: Number(log.actor.user.userId),
                                    name: log.actor.user.username || `User ${log.actor.user.userId}`,
                                    displayName: log.actor.user.displayName || log.actor.user.username || `User ${log.actor.user.userId}`,
                                };

                                // Log the action using our custom objects
                                logAction(
                                    'Manual Set Rank',
                                    actorUser as PartialUser,
                                    null,
                                    targetUser as PartialUser,
                                    `${oldRole.name} (${oldRole.rank}) â†’ ${newRole.name} (${newRole.rank})`
                                );
                            } catch (userError) {
                                Logger.error(`Failed to process user in audit log: ${userError.message}`, 'Audit');
                            }
                        }
                    }
                }
            } else if (!lastRecordedDate) {
                // First run, just set the timestamp without processing
                Logger.info(`Initialized audit log timestamp to ${new Date(mostRecentDate).toISOString()}`, 'Audit');
            }

            // Update our last recorded date for next time
            lastRecordedDate = mostRecentDate;
            Logger.info(`Updated last recorded audit log timestamp to ${new Date(lastRecordedDate).toISOString()}`, 'Audit');

            // If no new logs were found, increase check interval to reduce spam
            if (lastRecordedDate && mostRecentDate === lastRecordedDate && checkInterval < 300000) {
                checkInterval = Math.min(Math.floor(checkInterval * 1.5), 300000); // Max 5 minutes
                Logger.info(`No new logs found, increasing check interval to ${checkInterval / 1000} seconds`, 'Audit');
            }
        }
    } catch (err) {
        Logger.error('Error checking audit logs', 'Audit', err);
        consecutiveErrors++;

        // Increase check interval if we're getting errors
        if (consecutiveErrors > 3) {
            checkInterval = Math.min(Math.floor(checkInterval * 2), 600000); // Max 10 minutes if errors
            Logger.warn(`Multiple consecutive errors (${consecutiveErrors}), increasing check interval to ${checkInterval / 1000} seconds`, 'Audit');
        }
    }

    // Continue checking every interval even if there was an error, but with dynamic timing
    setTimeout(recordAuditLogs, checkInterval);
};

export { recordAuditLogs };